# 1. 실무에서 스레드를 직접 생성하면 안되는 이유

- 실무에서 스레드를 직접 생성해서 사용하면 **3가지 주요 문제가 발생**함
    - **스레드 생성 시간으로 인한 성능 문제**
        - 스레드는 생성 시 자신만의 호출 스택(call stack)을 가져야 하며, 이로 인해 많은 메모리(보통 1MB 이상)가 필요함
        - 스레드 생성은 운영체제 커널 수준에서 처리되어 CPU와 메모리 리소스를 많이 소모함
        - 운영체제 스케줄러가 스레드를 관리하므로 추가적인 오버헤드가 발생함
        - 예시: 작업마다 스레드를 새로 만들면, 작업 실행 시간보다 스레드 생성 시간이 더 오래 걸릴 수 있음
    - **스레드 관리 문제**
        - 서버의 CPU, 메모리 자원은 한정되어 있어 무한정 스레드를 만들 수 없음
        - 갑자기 많은 요청이 몰리면(예: 100개에서 10,000개로 증가) 시스템이 감당하지 못함
        - 안전한 종료, 인터럽트 등 스레드의 상태를 관리하기 어렵고, 실행 중인 스레드를 추적·관리해야 함
    - **Runnable 인터페이스의 불편함**
        - 반환값이 없음: run() 메서드는 결과를 반환하지 않아, 실행 결과를 얻으려면 별도의 변수와 동기화가 필요함
        - 예외 처리의 한계: run()은 체크 예외를 던질 수 없어, 예외 처리를 메서드 내부에서만 해야 함
        - 예시: 스레드가 실행한 결과를 멤버 변수에 저장하고, join() 후에 값을 꺼내야 함



## 2. 스레드 풀과 Executor 프레임워크의 등장 배경

- **스레드 풀(Pool) 개념**
    - 미리 필요한 만큼의 스레드를 만들어 두고, 작업이 오면 대기 중인 스레드를 할당하여 처리함
    - 작업 완료 후 스레드는 종료하지 않고 다시 풀에 반납되어 재사용됨
    - 스레드 풀을 사용하면 스레드 생성 시간을 절약하고, 필요한 만큼만 스레드를 관리할 수 있음
- **Executor 프레임워크의 역할**
    - 스레드 풀, 스레드 관리, Runnable의 불편함을 해결하는 자바 멀티스레드 도구
    - 실무에서는 직접 스레드를 생성하기보다 Executor 프레임워크를 주로 사용함
    - 생산자-소비자 문제도 함께 해결 가능
    - Executor 프레임워크는 멀티스레딩및 병렬 처리를 쉽게 사용할 수 있도록 다양한 기능을 제공함


## 3. Executor 프레임워크의 주요 구성 요소와 기본 사용법
![img.png](../img/img11.png)

- **생산자 소비자 패턴**
  - `생산자` : execute()로 작업을 호출하면 내부에서 큐에 작업을 보관한다. -> `main 스레드가 생산자가 된다.`
  - `소비자` : 스레드 풀에 있는 스레드가 소비자가 된다. 이후 소비자 중에 하나의 큐에


- **Executor 인터페이스**
    - 가장 단순한 작업 실행 인터페이스로 execute( Runnablecommand) 메서드만 제공
- **ExecutorService 인터페이스**
    - Executor를 확장하여 작업 제출, 제어, 종료 등 다양한 기능 제공
    - 대표 구현체는 ThreadPoolExecutor
    - 주요 메서드: submit(), close(), shutdown() 등
- **ThreadPoolExecutor**
    - 스레드 풀을 관리하는 대표적인 구현체
    - 생성자 주요 파라미터:
        - `corePoolSize`: 기본 스레드 수
        - `maximumPoolSize`: 최대 스레드 수
        - `keepAliveTime`: 초과 스레드의 생존 시간
        - `BlockingQueue`: 작업 대기 큐
    - 예시: `ThreadPoolExecutor(2,2,0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<>())`
    - - **상태 확인 유틸리티**
  - ThreadPoolExecutor의 상태(풀 내 스레드 수, 활성 스레드 수, 대기 작업 수, 완료 작업 수 등)를 출력하는 printState() 메서드 제공


## 4. ExecutorService의 우아한 종료(Graceful Shutdown)와 강제 종료

- 서버를 재시작할 때, **진행 중인 작업은 모두 완료하고 새로운 작업은 받지 않는 방식**을 우아한 종료(Graceful Shutdown)라 한다. 이는 서비스의 안정성을 위해 매우 중요하다.
    - 예시: 고객 주문 처리 중 서버가 갑자기 재시작되면 주문이 누락될 수 있으므로, 모든 주문 처리가 끝난 후 재시작하는 것이 바람직하다.
- ExecutorService는 종료와 관련된 다양한 메서드를 제공한다.
    - `shutdown()`: 새로운 작업을 받지 않고, 이미 제출된 작업을 모두 완료한 후 종료. 논블로킹 메서드.
    - `shutdownNow()`: 실행 중인 작업을 중단하고, 대기 중인 작업을 반환하며 즉시 종료. 인터럽트 발생.
    - `isShutdown()`, `isTerminated()`: 서비스 상태 확인.
    - `awaitTermination(timeout, unit)`: 지정된 시간 동안 작업 완료를 대기. 블로킹 메서드.
    - `close()`: 자바 19부터 지원. `shutdown()`과 유사.
- 우아한 종료 구현 예시:
    - `shutdown()` 호출 후, 10초간 `awaitTermination()`으로 정상 종료를 기다림.
    - 10초 내 종료되지 않으면 `shutdownNow()`로 강제 종료 시도, 다시 10초 대기.
    - 그래도 종료되지 않으면 로그로 알림.
    - 실제 로그 예시:
        - 정상 종료 시도 → 실패 → 강제 종료 시도 → 인터럽트 발생 → 종료 완료
- 주의점: 인터럽트를 받을 수 없는 코드(예: 무한 루프)는 강제 종료 후에도 남을 수 있으므로, 이런 경우 자바 프로세스를 강제 종료해야 한다.
- 결론: **기본적으로 우아한 종료를 시도하고, 일정 시간 내 종료되지 않으면 강제 종료**하는 것이 바람직하다. 종료 과정에서 로그를 남겨 문제를 추적할 수 있도록 해야 한다.


## 5. ThreadPoolExecutor의 동작 원리와 예시 분석

- 스레드 풀 생성 예시:
    - corePoolSize=2, maximumPoolSize=4, workQueue=ArrayBlockingQueue(2)
    - 최대 2개의 작업을 큐에 보관, 기본 2개, 최대 4개 스레드 사용
- 동작 과정:
    - 작업 요청이 들어오면 corePoolSize만큼 스레드를 먼저 생성
    - corePoolSize를 초과하면 큐에 작업을 저장
    - 큐가 가득 차면 maximumPoolSize까지 초과 스레드를 생성
    - 초과 스레드는 지정된 keepAliveTime(예: 3초) 동안 작업이 없으면 제거
    - 큐와 스레드가 모두 가득 차면 작업 거절(RejectedExecutionException 발생)
- 예시 로그 분석:
    - task1~task2: 스레드 생성 및 바로 실행
    - task3~task4: 큐에 저장
    - task5~task6: 초과 스레드 생성 및 실행
    - task7: 큐와 스레드 모두 가득 차서 거절 예외 발생
- 초과 스레드는 긴급 상황(요청 폭주)에 대응하기 위해 임시로 생성되며, 작업이 줄어들면 자동으로 제거된다.


## 6. 스레드 풀 전략: 고정 풀, 캐시 풀, 사용자 정의 풀

## 6.1 고정 풀 전략 (Fixed Thread Pool)

- 특징: 스레드 수가 고정되어 있어 CPU, 메모리 리소스 예측이 가능하고 안정적이다.
- 큐 사이즈는 무한대이므로 작업이 많이 쌓여도 서버가 다운되진 않지만, 작업 처리 속도보다 요청이 빠르면 큐에 작업이 계속 쌓여 응답이 느려질 수 있다.
- 예시: 2개의 스레드로 6개의 작업을 처리, 작업이 큐에 쌓여 순차적으로 처리됨.

## 6.2 캐시 풀 전략 (Cached Thread Pool)

- 특징: 기본 스레드 없이 초과 스레드만 사용, 초과 스레드 수 제한 없음, 큐 없이 SynchronousQueue 사용(저장 공간 0).
- 요청이 오면 바로 초과 스레드를 생성해 처리, 작업이 줄면 스레드도 자동으로 줄어듦.
- 매우 빠르고 유연하지만, 요청이 폭주하면 스레드가 무한정 늘어나 시스템이 다운될 수 있음.
- 예시: 4개의 작업 요청 시 4개의 스레드가 즉시 생성되어 동시에 처리됨.

## 6.3 사용자 정의 풀 전략 (Custom Thread Pool)

- 일반 상황에는 고정 스레드로 안정적으로 운영, 긴급 상황에는 초과 스레드로 빠르게 대응, 그 이상은 작업 거절.
- 예시: 기본 100개, 최대 200개 스레드, 큐 1000개 설정 시
    - 1100개 작업: 1000개 큐 대기, 100개 실행(11초 소요)
    - 1200개 작업: 1000개 큐 대기, 200개 실행(6초 소요)
    - 1201개 작업: 거절 예외 발생

## 7. 작업 거절(RejectedExecution) 정책

- ThreadPoolExecutor는 작업 거절 시 다양한 정책을 제공한다.
    - **AbortPolicy**: 기본 정책, `RejectedExecutionException` 예외 발생
    - **DiscardPolicy**: 거절된 작업을 조용히 버림, 예외 없음
    - **CallerRunsPolicy**: 작업을 요청한 스레드가 직접 작업을 수행, 생산 속도 조절 효과
    - **사용자 정의 정책**: RejectedExecutionHandler 인터페이스 구현으로 맞춤형 거절 처리 가능
- 예시:
    - AbortPolicy: 큐와 스레드가 가득 차면 예외 발생, 로그로 알림
    - DiscardPolicy: 초과 작업은 조용히 무시됨
    - CallerRunsPolicy: main 스레드가 직접 작업을 수행, 생산 속도 자연스럽게 조절
    - 사용자 정의: 거절된 작업 수를 로그로 남김

## 8. 실무 전략 선택과 최적화 조언

- **고정 스레드 풀 전략**: 트래픽이 일정하고 시스템 안전성이 가장 중요할 때 적합
- **캐시 스레드 풀 전략**: 일반적으로 성장하는 서비스에 적합
- **사용자 정의 풀 전략**: 다양한 상황에 대응해야 할 때 적합
- **최적화는 필요할 때만**: 미래의 불확실한 상황을 대비해 과도한 최적화는 피하고, 현재 상황에 맞는 최적화와 모니터링이 중요하다.
- 서비스가 성장하면 그때 더 나은 최적화 방법을 선택하면 된다.
- 서버가 다운되지 않도록 적절한 거절 정책을 설정하는 것이 중요하다.