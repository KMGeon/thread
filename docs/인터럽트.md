# Java Thread 인터럽트 정리

## 1. 변수 기반 스레드 중단 vs 인터럽트 기반 중단

### 1.1 변수 기반 중단의 한계
```java
// Interrupt.java 예시
volatile boolean runFlag = true;

while (runFlag) {
    Utils.logger("작업 중");
    Utils.timeSleep(3000); // 3초간 대기
}
```

**문제점: 즉시 중단되지 않는 이유**
- `runFlag = false`로 설정해도 **현재 실행 중인 작업이 완료될 때까지 기다려야 함**
- `Utils.timeSleep(3000)` 실행 중에는 `while` 조건을 체크하지 않음
- **최대 3초의 지연 시간** 발생 (현재 sleep이 끝날 때까지)

**실행 순서:**
1. `runFlag = false` 설정 → 스레드는 여전히 `sleep(3000)` 실행 중
2. 3초 후 `sleep` 완료 → `while` 조건 체크 → 루프 탈출

### 1.2 인터럽트 기반 중단의 장점
```java
// Interrupt2.java 예시
try {
    while (true) {
        logger("작업 중");
        Thread.sleep(3000); // 인터럽트 감지 가능한 메서드
    }
} catch (InterruptedException e) {
    // 즉시 예외 발생하여 처리
}
```

**장점: 즉시 중단되는 이유**
- `Thread.interrupt()` 호출 시 **대기 중인 스레드를 즉시 깨움**
- `InterruptedException` 발생으로 **즉시 예외 처리 블록으로 이동**
- **지연 시간 없이 즉시 반응**

---

## 2. 인터럽트 동작 메커니즘 상세 분석

### 2.1 인터럽트 플래그와 상태 변화

```java
Thread thread = new Thread(task, "work");
thread.start();
// 스레드 상태: RUNNABLE

thread.interrupt(); // 인터럽트 플래그 설정
// 스레드 상태: 여전히 RUNNABLE (즉시 예외 발생 X)
```

### 2.2 인터럽트 예외가 발생하는 시점

**핵심:** 인터럽트는 **특정 메서드에서만** `InterruptedException`을 발생시킨다.

#### 인터럽트 예외를 던지는 메서드들:
- `Thread.sleep(long millis)`
- `Object.wait()`
- `Thread.join()`
- `BlockingQueue.take()`, `put()`
- `CountDownLatch.await()`
- `Semaphore.acquire()`

#### 동작 과정:
```java
// 1. 스레드가 while(true) 루프 실행 중 (RUNNABLE 상태)
while (true) {
    logger("작업 중");           // ← 이 시점에 interrupt() 호출되어도 예외 X
    Thread.sleep(3000);        // ← 이 메서드에서 InterruptedException 발생!
}
```

### 2.3 인터럽트 상태 확인

```java
// 인터럽트 호출 직후
logger("work 스레드 인터럽트 상태1 = " + thread.isInterrupted()); // true

// InterruptedException 처리 후
logger("work 스레드 인터럽트 상태2 = " + Thread.currentThread().isInterrupted()); // false
```

**중요:** `InterruptedException` 발생 시 **인터럽트 플래그가 자동으로 초기화**됨

---

## 3. 실행 시나리오 분석

### Scenario 1: 변수 기반 중단
```
시간   스레드 상태              동작
0초    RUNNABLE               작업 시작
3초    RUNNABLE               "작업 중" 출력 후 sleep(3000) 시작
4초    TIMED_WAITING          main에서 runFlag = false 설정
6초    RUNNABLE               sleep 완료, while 조건 체크, 루프 탈출
```
**지연시간: 2초**

### Scenario 2: 인터럽트 기반 중단
```
시간   스레드 상태              동작
0초    RUNNABLE               작업 시작  
3초    TIMED_WAITING          "작업 중" 출력 후 sleep(3000) 시작
4초    RUNNABLE               interrupt() → InterruptedException 즉시 발생
```
**지연시간: 거의 0초**

---

## 4. 인터럽트 처리 모범 사례

### 4.1 기본 패턴
```java
try {
    while (!Thread.currentThread().isInterrupted()) {
        // 작업 수행
        doSomeWork();
        Thread.sleep(1000); // 인터럽트 감지 포인트
    }
} catch (InterruptedException e) {
    // 인터럽트 상태 복원 (필요시)
    Thread.currentThread().interrupt();
    
    // 정리 작업
    cleanup();
}
```

### 4.2 인터럽트 무시하지 않기
```java
// 잘못된 방법 - 인터럽트 무시
catch (InterruptedException e) {
    // 아무것도 하지 않음 - 위험!
}

// 올바른 방법 - 인터럽트 상태 복원
catch (InterruptedException e) {
    Thread.currentThread().interrupt(); // 인터럽트 상태 복원
    return; // 또는 적절한 종료 처리
}
```

---

## 5. isInterrupted() vs interrupted() 차이점

**🎯 핵심**: `isInterrupted()`는 상태만 확인, `interrupted()`는 확인하고 즉시 false로 리셋한다.

### ❌ 문제 상황: isInterrupted() 사용

```java
public void problematicFileProcessor() {
    System.out.println("인터럽트 상태: " + Thread.currentThread().isInterrupted()); // false
    
    // 다른 스레드에서 interrupt() 호출
    Thread.currentThread().interrupt(); // 인터럽트 상태 = true
    
    // 1단계: 메인 작업 루프
    while (!Thread.currentThread().isInterrupted()) { // ← 상태만 확인 (true)
        processFile();
    }
    // → 반복문 종료, 하지만 인터럽트 상태는 여전히 true!
    
    System.out.println("반복문 후 인터럽트 상태: " + Thread.currentThread().isInterrupted()); // true
    
    // 2단계: 정리 작업
    try {
        cleanupResources(); // 내부에 Thread.sleep(100) 있다면?
    } catch (InterruptedException e) {
        // 🚨 어? 여기서 또 예외가?!
        System.out.println("정리 중 예외 발생!"); 
    }
}
```

**흐름**: 인터럽트 상태 true → `isInterrupted()` 확인 → 반복문 종료 → **상태 여전히 true** → cleanup에서 또 예외!

### ✅ 해결책: interrupted() 사용

```java
public void fixedFileProcessor() {
    System.out.println("인터럽트 상태: " + Thread.currentThread().isInterrupted()); // false
    
    // 다른 스레드에서 interrupt() 호출
    Thread.currentThread().interrupt(); // 인터럽트 상태 = true
    
    // 1단계: 메인 작업 루프
    while (!Thread.interrupted()) { // ← 상태 확인하고 동시에 false로 리셋!
        processFile();
    }
    // → 반복문 종료, 인터럽트 상태는 이미 false로 변경됨
    
    System.out.println("반복문 후 인터럽트 상태: " + Thread.currentThread().isInterrupted()); // false
    
    // 2단계: 정리 작업
    cleanupResources(); // 더 이상 InterruptedException 발생 안함!
    System.out.println("정리 완료!");
}
```

**흐름**: 인터럽트 상태 true → `interrupted()` 확인 + false 리셋 → 반복문 종료 → **상태는 false** → cleanup 안전 실행!

### 📊 실행 결과 비교

```java
// isInterrupted() 사용시
인터럽트 상태: false
반복문 후 인터럽트 상태: true    ← 문제!
정리 중 예외 발생!

// interrupted() 사용시  
인터럽트 상태: false
반복문 후 인터럽트 상태: false   ← 해결!
정리 완료!
```

**⚡ 주의사항**: 인터럽트 처리 완료 후에는 반드시 상태를 정상(false)으로 돌려야 이후 코드가 예상대로 동작함. `interrupted()`는 이를 자동으로 해주는 것!

---

## 6. Thread.yield()를 이용한 CPU 효율 개선

### 6.1 yield()의 개념
- 스레드가 바쁘지 않을 때, `Thread.yield()`를 호출해 CPU 실행 기회를 다른 스레드에 양보
- **스케줄러에게 힌트**를 줄 뿐, 반드시 다른 스레드가 실행된다는 보장은 없음
- CPU 코어 수가 많으면 효과가 미미할 수 있음

### 6.2 sleep()과 yield()의 차이점

| 구분 | Thread.sleep() | Thread.yield() |
|------|---------------|---------------|
| **대기 시간** | 지정한 시간 동안 완전히 멈춤 | 잠깐 실행 대기 상태로 변경 |
| **스레드 상태** | TIMED_WAITING | RUNNABLE → RUNNABLE |
| **보장** | 최소 지정 시간은 대기 | 양보 힌트만 제공 |
| **CPU 사용** | 완전히 양보 | 다른 스레드에 기회 제공 |

### 6.3 실전 적용 예시

#### 프린터 작업 큐 예제
```java
public class PrinterManager {
    private Queue<PrintJob> jobQueue = new LinkedList<>();
    
    public void processPrintJobs() {
        while (true) {
            if (jobQueue.isEmpty()) {
                // 작업이 없을 때 CPU 양보
                Thread.yield(); // ← 불필요한 반복문 실행 줄임
                continue;
            }
            
            PrintJob job = jobQueue.poll();
            processJob(job);
        }
    }
}
```

#### 1000개 스레드 실행 예제
```java
// yield() 없이 실행
for (int i = 0; i < 1000; i++) {
    new Thread(() -> {
        for (int j = 0; j < 10; j++) {
            System.out.print(j + " ");
        }
    }).start();
}
// 결과: 한 스레드가 연속으로 많이 실행될 가능성 높음

// yield() 사용하여 실행
for (int i = 0; i < 1000; i++) {
    new Thread(() -> {
        for (int j = 0; j < 10; j++) {
            System.out.print(j + " ");
            Thread.yield(); // ← 다른 스레드에 기회 제공
        }
    }).start();
}
// 결과: 여러 스레드가 번갈아 가면서 실행됨
```

### 6.4 yield() 사용 가이드라인

**✅ 적절한 사용 시기:**
- 작업 큐가 비어있을 때
- 무한 루프에서 조건 체크 시
- CPU 집약적 작업 사이사이

**❌ 부적절한 사용:**
- 성능이 중요한 코드에서 남용
- 정확한 타이밍이 필요한 경우
- 이미 충분한 대기가 있는 코드

```java
// 좋은 예시
while (condition) {
    if (noWorkToDo()) {
        Thread.yield(); // CPU 양보
        continue;
    }
    doWork();
}

// 나쁜 예시
for (int i = 0; i < 1000000; i++) {
    Thread.yield(); // 성능 저하!
    calculation(i);
}
```

---

## 7. 요약

| 구분 | 변수 기반 중단 | 인터럽트 기반 중단 | yield() 활용 |
|------|-------------|-----------------|-------------|
| **반응 속도** | 지연됨 (대기 작업 완료까지) | 즉시 | 힌트 수준 |
| **구현 복잡도** | 단순 | 중간 | 매우 단순 |
| **권장 사용** | 간단한 루프 | 대기가 포함된 작업 | CPU 효율 개선 |
| **안전성** | 높음 | 중간 (상태 관리 필요) | 높음 |

**결론:** 
- **즉시 반응**이 필요한 경우: **인터럽트 + interrupted() 사용**
- **단순한 플래그 기반** 중단으로 충분한 경우: **변수 사용**
- **CPU 효율**을 높이고 싶은 경우: **yield() 추가 활용**
- 두 방법을 **조합**하여 사용하는 것이 가장 안전하고 효과적